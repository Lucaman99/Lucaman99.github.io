<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-08-11 Mon 13:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Introduction to derived functors and derived categories</title>
<meta name="author" content="Jack Ceroni" />
<meta name="description" content="Directory" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<style> body {font-size:15px;background-color:#FDF7D6} a {color:blue;} </style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Introduction to derived functors and derived categories</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgfd3ee85">1. Introduction</a></li>
<li><a href="#orgf6ee1c6">2. Category theory basics</a></li>
<li><a href="#orgd1c8bd5">3. Abelian categories</a></li>
<li><a href="#org8e0363f">4. Derived functors</a></li>
<li><a href="#orgd9e6454">5. Derived categories</a></li>
<li><a href="#org2996454">6. Sheaf cohomology and hypercohomology</a></li>
<li><a href="#org1ea3a7b">7. Hochschild homology and cohomology</a></li>
</ul>
</div>
</div>
<p>
<i>Originally posted:</i>
</p>

<hr />

<div id="outline-container-orgfd3ee85" class="outline-2">
<h2 id="orgfd3ee85"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
The goal of this post is to explain the general construction of derived functors and derived categories, then use these ideas to introduce the general
notion of sheaf cohomology and hypercohomology. I might also talk a bit about Hochschild homology/cohomology (which has a very nice explanation via derived functors).
</p>
</div>
</div>

<div id="outline-container-orgf6ee1c6" class="outline-2">
<h2 id="orgf6ee1c6"><span class="section-number-2">2.</span> Category theory basics</h2>
<div class="outline-text-2" id="text-2">
<p>
In this section, I'll go over a few basic ideas in category theory.
</p>

<p>
<b>Definition 2.1</b> (Initial and final objects). Let \(\mathcal{C}\) be a category, an object \(I\) in \(\mathcal{C}\) is said to be initial if for any other object \(X\),
there is a unique morphism \(I \to X\). An object \(T\) is terminal if for any \(X\), there is a unique morphism \(X \to T\).
An object is said to be a zero object (denoted \(0\)) if it is both initial and terminal.
</p>

<p>
<b>Remark 2.1.</b> It is easy to see that initial and final objects (if they exists) are unique up to unique isomorphism.
</p>

<p>
<b>Definition 2.2</b> (Comma category). Let \(F : \mathcal{C} \rightarrow \mathcal{D}\) be a functor, let \(X\) be an object of \(D\). The comma category \((X \downarrow F)\) is defined as follows:
</p>

<ul class="org-ul">
<li>The objects are pairs \((C, f : x \rightarrow F(C))\) for objects \(C \in \text{Obj}(\mathcal{C})\).</li>
<li>The morphisms between \((C, f)\) and \((C', f' : X \rightarrow F(C'))\) are morphisms \(h : C \rightarrow C'\) in \(\mathcal{C}\) such that \(F(h) \circ f = f'\).</li>
</ul>

<p>
It is very easy to verify that we have defined a valid category. We can also define another type of comma category, \((F \downarrow X)\), where we look at objects of the form \((C, f : F(C) \rightarrow x)\),
and define the morphisms in the obvious way.
</p>

<p>
<b>Example 2.1.</b> The category of pointed topological spaces is precisely \((\cdot \downarrow \textbf{Top})\).
</p>

<p>
<b>Definition 2.3</b> (Universal morphism). A universal morphism is an initial object in \((X \downarrow F)\), a particular comma category, or a terminal object in \((F \downarrow X)\). Intuitively, a universal morphism encodes a property which characterizes
some object up to isomorphism. We can unravel the definition of a universal morphism to better conceptualize it.
In particular, a universal morphism (in \((X \downarrow F)\)) is a pair \((C, f : X \rightarrow F(C))\) such that for any other pair \((C', f' : X \rightarrow F(C'))\), there is a unique arrow \(h : C \rightarrow C'\) such that the following diagram commutes:
</p>


<div id="org73e71c6" class="figure">
<p><img src="./assets/uni_prop.png" alt="uni_prop.png" width="250px" />
</p>
</div>

<p>
<b>Corollary 2.1.</b> A universal morphism is unique up to unique isomorphism in the comma category: this follows immediately from the fact that initial and terminal objects are unique up
to unique isomorphism.
</p>

<p>
<b>Example 2.2</b> (Tensor algebra). The tensor algebra of a vector space is a great example of an object characterized via a universal property. In particular, given some vector space \(V\) over \(k\), the property
which characterizes the tensor algebra \(T(V)\) is that any linear map \(V \rightarrow A\) of \(V\) to a \(k\) -algebra extends uniquely to an algebra homomorphism from \(T(V)\) to \(A\).
Let \(\text{For} : \textbf{Alg}_k \rightarrow \textbf{Vect}_k\) be the forgetful functor which sends a \(k\) -algebra to its underlying vector space. We take \(F\) to be \(\text{For}\), and
we take \(X = V\). Our desired object is an initial object \((T(V), f : V \rightarrow \text{For}(T(V)))\) in the comma category, which is to say that for any \(A \in \textbf{Alg}_k\) and
linear map \(f' : V \rightarrow \text{For}(A)\), there must be a unique algebra homomorphism \(g : T(V) \rightarrow A\) such that \(\text{For}(g) \circ f = f'\).
</p>

<p>
<b>Remark 2.2.</b> A word of caution: this formulation of a universal morphism can fail to nicely capture many instances where a "universal property" may describe a particular object.
A good example is the tensor product. Technically, one can formulate a definition of the tensor product of two vector spaces, \(V \otimes W\), via the language of universal morphisms (see <a href="https://ncatlab.org/nlab/show/tensor+product">nLab</a>),
but in practice, it is better to just say that \(V \otimes W\) is an object of \(\textbf{Vect}_k\) and a bilinear map \(j : V \times W \rightarrow V \otimes W\) such that
for any bilinear map \(f : V \times W \rightarrow Z\), there is a unique morphism \(h : V \otimes W \rightarrow Z\) such that \(h \circ j = f\). The reason why we cannot use a universal morphism
naively in this case is because of the <i>bilinear</i> attribute of the maps \(j\) and \(f\) (we can't specify this particular attribute as native to the category in which we are
working because we also need to work with the standard linear map \(h\)). Nevertheless, it is easy to check directly that this definition uniquely characterizes \(V \otimes W\) (if it exists)
up to unique isomorphism.
</p>

<p>
Having introduced universal properties, we can look at a related idea: adjoint functors.
</p>

<p>
<b>Mantra 2.1.</b> The best, succinct way to think of a functor \(F : \mathcal{D} \rightarrow \mathcal{C}\) adjoint to functor \(G : \mathcal{C} \rightarrow \mathcal{D}\) is that \(F\) is the most efficient way to systematically
"solve the problem" posed by \(G\). If \(G\) is, for example, a forgetful functor which throws away some of the structure of category \(\mathcal{C}\), is there a method which reconstructs an element of \(\mathcal{C}\) from \(\mathcal{D}\), and imposes the
minimal amount of extra structure possible? If such a method exists, and is functorial, in the sense that it works the same for any object, then it can be described via a functor \(F : \mathcal{D} \rightarrow \mathcal{C}\)
which is adjoint to \(G\).
</p>

<p>
<b>Mantra 2.2.</b> Another way to internalize this same intuition is via universal properties. When
we find an object which satisfies a universal property, we are effectively finding the "most efficient" object which satisfies some desired property. An adjoint functor is a technique to define such universal
objects at a global, categorical level, rather than locally. To be more specific, writing down a universal morphism is dependent on a <i>particular choice</i> of object \(X\) relative to which we define a comma category.
One way to interpret the utility of an adjoint functor is that it "chooses every \(X\) at once" in a functorial manner. In the previous tensor algebra example, we are choosing a particular \(X = V\), and defining \(T(V)\)
via a universal property. In fact, \(T\) should be a functor in its own right, and it should work for <i>every</i> choice of \(V\) is a functorial manner. Indeed, it is the case that \(T\) is a functor adjoint to \(\text{For}\).
</p>

<p>
<b>Definition 2.4</b> (Adjoint functor). A functor \(F : \mathcal{D} \rightarrow \mathcal{C}\) is said to be <i>left-adjoint</i> if for each \(X \in \text{Obj}(\mathcal{C})\), there exists a universal morphism
in \((F \downarrow X)\). The existence of a universal morphism simply means that there is some \((G(X), f_X : F(G(X)) \rightarrow X)\) such that for any other \((C, g : F(C) \rightarrow X)\), there is a
unique morphism \(h : C \rightarrow G(X)\) where \(f_X \circ F(h) = g\). From here, it is possible to show that we can define a functor \(G : \mathcal{C} \rightarrow \mathcal{D}\) such that \(f_X \circ F(G(h)) = h \circ f_{X'}\) for all \(h : X' \rightarrow X\), as one might
expect/hope. In particular, we simply let \(G\) take object \(X\) to \(G(X)\). Additionally, given arrow \(h : X' \rightarrow X\) in \(\mathcal{C}\), we obtain objects \((G(X), f_X : F(G(X)) \rightarrow X)\)
and \((G(X'), h \circ f_{X'} : F(G(X')) \rightarrow X)\). We then obtain unique morphism \(G(h) : G(X') \rightarrow G(X)\) where \(f_X \circ F(G(h)) = h \circ f_{X'}\), as desired. To prove that this
mapping of objects/arrows in a valid functor, we simply note that \(G\) takes identity arrows to identity arrows and preserves compositions due to uniqueness of \(G(h)\).
</p>

<p>
There is a similar, dual construction, where we say that \(G : \mathcal{C} \rightarrow \mathcal{D}\) is <i>right-adjoint</i> if for each \(X \in \text{Obj}(\mathcal{D})\), there exists a universal morphism
in \((X \downarrow G)\). We define functor \(F : \mathcal{D} \rightarrow \mathcal{C}\) analogously.
</p>

<p>
<b>Claim 2.1.</b> If \(F : \mathcal{D} \rightarrow \mathcal{C}\) is left-adjoint, and \(G : \mathcal{C} \rightarrow \mathcal{D}\) is the corresponding induced functor, then \(G\) is right-adjoint,
and the corresponding induced functor is \(F\). Similarly, if \(G : \mathcal{C} \rightarrow \mathcal{D}\) is right-adjoint and \(F\) is the induced functor, then \(F\) is left-adjoint, and its
induced functor is \(G\).
</p>

<p>
<i>Proof.</i> Let's look at the first case. We need to show that for each \(X\) in \(\mathcal{D}\), then there is initial object \((F(X), f_X : X \rightarrow G(F(X)))\)
in the comma category. Thus, we need to produce a unique arrow \(g : F(X) \rightarrow Y\) for some \((Y, h : X \rightarrow G(Y))\)
such that \(G(g) \circ f_X = h\). Of course, we know that \(F\) is left-adjoint with induced functor \(G\), so we can find universal morphism in \((F \downarrow Y)\). This will be
some terminal \((G(Y), g_Y : F(G(Y)) \rightarrow Y)\). So, given \((Z, p : F(Z) \rightarrow Y)\), we have unique \(p' : Z \rightarrow G(Y)\) such that \(g_Y \circ F(p') = p\).
In particular, we can set \(Y = F(X)\) and \(Z = X\) with \(p = \text{id}\), to get \(p' : X \rightarrow G(F(X))\) where \(g_{F(X)} \circ F(p') = \text{id}\). In addition, recall
that \(g_Y\) satisfies the naturality condition:
</p>

\begin{equation}
g_Y \circ (F \circ G)(p) = p \circ g_{Y'}
\end{equation}

<p>
for every \(p : Y' \rightarrow Y\). We claim that we can set \(f_X = p'\). Then, given \((Y, h : X \rightarrow G(Y))\), consider \(g_Y \circ F(h)\): we claim that this is the \(g\) we need.
Then we have arrow \(G(g) \circ f_X = G(g_Y) \circ G(F(h)) \circ p'\), and applying \(F\) gives us \((F \circ G)(g_Y) \circ (F \circ G)(F(h)) \circ F(p')\).
From the naturality condition,
</p>

\begin{equation}
g_Y \circ F(h) \circ g_{F(X)} = g_Y \circ g_{(F \circ G)(Y)} \circ (F \circ G)(F(h)) = g_Y \circ (F \circ G)(g_Y) \circ (F \circ G)(F(h))
\end{equation}

<p>
where the final equality comes from the naturality condition for \(p = g_Y\). It follows that
</p>

\begin{equation}
g_Y \circ F(G(g_Y \circ F(h)) \circ p') = g_Y \circ (F \circ G)(g_Y) \circ (F \circ G)(F(h)) \circ F(p') = g_Y \circ F(h) \circ g_{F(X)} \circ F(p') = g_Y \circ F(h)
\end{equation}

<p>
and by uniqueness, \(h = G(g_Y \circ F(h)) \circ p'\), or in other words, \(G(g) \circ f_X = h\), as desired. Thus, \(G\) is right-adjoint with induced functor \(F\). Proving the second case
is follows more or less the same process, so we will omit the proof. \(\blacksquare\)
</p>

<p>
<b>Example 2.3</b> (Tensor algebra, again). The forgetful functor \(\text{For} : \textbf{Alg}_k \rightarrow \textbf{Vect}_k\) of Example 2.2 is right-adjoint (if the tensor algebra \(T(V)\) exists). In particular, we have
initial \((T(V), f : V \rightarrow \text{For}(T(V)))\) for each \(V \in \text{Obj}(\textbf{Vect}_k)\), which is a universal morphism in \((V \downarrow \text{For})\).
</p>

<hr />

<p>
Now, let us discuss the notion of limits and colimits, which will prove to be useful in our discussion of Abelian categories. Similar to universal morphisms and adjoints, we can think
of limits and colimits as particular initial/terminal objects in a category.
</p>

<p>
<b>Definition</b> (Diagram). A \(\mathcal{D}\) -shaped diagram in \(\mathcal{C}\) is a functor \(F : \mathcal{D} \rightarrow \mathcal{C}\).
We can form a category of \(\mathcal{D}\) -shaped diagrams in \(\mathcal{C}\), \(\mathcal{D}[\mathcal{C}]\), by taking these functors are objects, and natural transformations as arrows.
</p>

<p>
<b>Definition</b> (Cone). If \(F : \mathcal{D} \rightarrow \mathcal{C}\) is a \(\mathcal{D}\) -shaped diagram in \(\mathcal{C}\), and \(Y\) is an object in \(\mathcal{C}\), we define a cone from \(Y\) to \(F\) to be a collection of morphisms
\(\psi_X : Y \rightarrow F(X)\)  for each object \(X\) in \(\mathcal{C}\), such that the following diagrams commute:
</p>


<div id="org672aaaa" class="figure">
<p><img src="./assets/cone.png" alt="cone.png" width="250px" />
</p>
</div>

<p>
for each arrow \(f : X \rightarrow X'\). Similarly, we define a cone from \(F\) to \(Y\) (also called a co-cone) by reversing all arrows in the above diagram. One can also formulate cones in terms of an appropriate comma category,
if they wish. The category of cones to \(F\) takes cones from some object to \(F\) as objects, and as morphisms, arrows \(g : Y' \rightarrow Y\) in \(\mathcal{C}\) making the following diagrams commute:
</p>


<div id="org4a92574" class="figure">
<p><img src="./assets/cone_morphism.png" alt="cone_morphism.png" width="250px" />
</p>
</div>

<p>
with the category of co-cones (or cones from \(F\)) being defined by again reversing the arrows in the above diagram. Checking that these are categories is easy.
</p>

<p>
<b>Definition.</b> If \(F : \mathcal{D} \rightarrow \mathcal{C}\) is a diagram, a limit \(\lim F\) is an initial object in the category of cones going to \(F\).
Similarly, a colimit \(\text{colim} \ F\) is a final object in the category of cones going from \(F\). For a more detailed explanation of
limits and colimits, and how they are categorical generalizations of inverse limits and direct limits, see <a href="https://lucaman99.github.io/mathblog/groupoid_svk.html">my previous blog post</a>.
</p>

<p>
Using limits and colimits, we are able to define an <i>equalizer</i> within a category, which can be thought of as a categorical generalization of "the set of arguments where
two functions agree".
</p>

<p>
<b>Definition.</b> Let \(\mathcal{C}\) be a category, let \(X\) and \(Y\) be objects, and let \(f, g : X \rightarrow Y\) be arrows. Taking \(X\) and \(Y\) as objects, \(f\), \(g\), and the identity arrows as morphisms,
we form a subcategory, and if we let \(\mathcal{D} = \{1, 2\}\) with arrows \(a\) and \(b\) pointing from \(1\) to \(2\) (along with identity arrows), we easily can form a diagram \(F : \mathcal{D} \rightarrow \mathcal{C}\) sending
\(a\) to \(f\) and \(b\) to \(g\). The equalizer \(\text{Eq}(f, g)\) is \(\lim F\). Unpacking this definition, the equalizer is an object \(C \in \mathcal{C}\) and maps
\(\psi_X : C \rightarrow X\) and \(\psi_Y : C \rightarrow Y\) such that \(g \circ \psi_X = \psi_Y = f \circ \psi_x\) which satisfy the required universal property. Similarly,
the coequalizer \(\text{Coeq}(f, g)\) is \(\text{colim} \ F\).
</p>

<p>
<b>Remark.</b> One can immediately see how this generalizes the notion of "the set on which two functions are equal". Being sloppy and abusing notation, we can have \(C = \{(x, y) \ | \ y = f(x) = g(x)\}\),
\(\psi_X\) the projection onto the first argument, and \(\psi_Y\) projection onto the second: then \(C\) satisfies the desired criterion. Ignore this remark is you find it too hand-wavy.
</p>

<p>
To conclude, let us briefly introduce the notion of products and coproducts, which are another crucial component of Abelian categories.
</p>

<p>
<b>Definition.</b> Let \(\mathcal{C}\) and \(\mathcal{D}\) be categories, where \(\mathcal{D}\) is an "index set" (i.e. it has no non-identity morphisms), and consists of set of objects \(I\). Suppose
\(F : \mathcal{D} \rightarrow \mathcal{C}\) is a diagram, which simply amounts to choosing some indexed family \((X_i)_{i \in I}\) of objects \(X_i\) in \(\mathcal{C}\). Then a product of the \(X_i\)
is a limit of \(F\). Unrolling this definition, it is object \(C\) in \(\mathcal{C}\), along with morphisms \(\pi_i : C \rightarrow X_i\) (projections) which is initial in the cone category.
Similarly, a coproduct is a colimit of \(F\).
</p>
</div>
</div>

<div id="outline-container-orgd1c8bd5" class="outline-2">
<h2 id="orgd1c8bd5"><span class="section-number-2">3.</span> Abelian categories</h2>
<div class="outline-text-2" id="text-3">
<p>
Here, we will develop some central results revolving around <i>Abelian categories</i>, which were introduced by Grothendieck in his Tohoku paper, and provide the
arena in which it makes sense to talk about exact sequences, homology, and cohomology is a general, categorical sense.
</p>

<p>
We need to begin with a lot of definitions (basically a collection of categorical generalizations of things which come up frequently in algebra).
</p>

<p>
<b>Definition 3.1</b> (Preadditive category). A preadditive category \(C\) is a category such that each hom-set has the structure of an Abelian group, with composition being bilinear over the group addition:
</p>
\begin{align}
    f \circ (g + h) = (f \circ g) + (f \circ h) \ \ \ \ \text{and} \ \ \ \ (g + h) \circ f = (g \circ f) + (h \circ f).
\end{align}

<p>
<b>Definition 3.2</b> (Zero morphisms). Let \(\mathcal{C}\) be a category, an arrow \(f : X \rightarrow Y\) is said to be <i>constant</i> if for any morphisms \(g, h : W \rightarrow X\), we have \(f \circ g = f \circ h\).
An arrow is said to be <i>coconstant</i> if for any morphisms \(g, h : Y \rightarrow Z\), we have \(g \circ f = h \circ f\). A morphism which is both constant and coconstant is called a <i>zero morphism</i>. We say that \(C\) is a category
<i>with zero morphisms</i> such that for every two objects \(X\) and \(Y\), there is a morphism \(0_{XY} : X \rightarrow Y\) such that for any two arrows \(f : X \rightarrow Y\) and \(g : Y \rightarrow Z\), the following diagrams commute:
</p>


<div id="orgc5f49d6" class="figure">
<p><img src="./assets/zeros.png" alt="zeros.png" width="250px" />
</p>
</div>

<p>
<b>Remark 3.1.</b> Note that if \(\mathcal{C}\) is a category with zero morphisms, then the arrows \(0_{XY}\) are unique. To see this, let \(Z = Y\), let \(g = \text{id}\), let \(f = 0_{XY}'\): some other morphism
satisfying the same criteria as \(0_{XY}\). Then applying the diagram, we find that \(0_{XY} = 0_{YY} \circ 0_{XY}'\) and \(0_{XY}' = 0_{YY} \circ 0_{XY}'\), so \(0_{XY} = 0_{XY}'\). We can also check
that all of the \(0_{XY}\) are zero morphisms. We have \(0_{XY} = 0_{YZ} \circ f\) for any arrow \(f : X \rightarrow Y\) and we have \(g \circ 0_{XY} = 0_{XZ}\) for any arrow \(g : Y \rightarrow Z\): this immediately gives us what we want.
</p>

<p>
<b>Claim 3.1.</b> If \(\mathcal{C}\) is an object with zero object \(\textbf{0}\), then \(\mathcal{C}\) has zero morphisms. In particular, we have natural maps \(t_X : X \rightarrow \textbf{0}\) and \(i_Y : \textbf{0} \rightarrow Y\),
and \(0_{XY} = i_Y \circ t_X\) endow \(\mathcal{C}\) with the structure of a category with zero morphisms.
</p>

<p>
<i>Proof.</i> Let \(f : X \rightarrow Y\) and \(g : Y \rightarrow Z\) be arrows. We note that \(0_{YZ} \circ f = i_Z \circ (t_Y \circ f)\) and \(g \circ 0_{XY} = (g \circ i_Y) \circ t_X\). Of course,
\(t_Y \circ f : X \rightarrow \textbf{0}\) must be equal to \(t_X\) and \(g \circ i_Y\) must be \(i_Z\), so both compositions are equal to \(0_{XZ}\), as desired. \(\blacksquare\)
</p>

<p>
Using the concept of zero morphisms, and the previously introduced concept of equalizers (and coequalizers), we are able to write down a natural definition of the kernel (and cokernel).
Note that kernels and cokernels will not always exist in a given category (as a given category may not contain certain equalizers/coequalizers).
</p>

<p>
<b>Definition 3.3</b> (Kernels and cokernels). Given arrow \(f : X \rightarrow Y\) in category \(\mathcal{C}\) with zero morphisms, \(\text{Ker}(f) = \text{Eq}(f, 0_{XY})\), the equilizer of
\(f\) and \(0_{XY}\). In addition, \(\text{Coker}(f) = \text{Coeq}(f, 0_{XY})\), the coequalizer of \(f\) and \(0_{XY}\).
</p>

<p>
<b>Definition 3.4</b> (Image). Using the concept of kernels/cokernels, we are able to define the <i>image</i> of an arrow \(f : X \rightarrow Y\) as well. In particular, if cokernel \(\text{Coker}(f)\) exists, then
we have object \(Q\) and "quotient" morphism \(q : Y \rightarrow Q\). Intuitively, if \(Q\) is supposed to generalize \(Y/\text{Im}(f)\) in the case that we are operating in, say, the category of vector spaces,
then we should have \(\text{Ker}(q) \simeq \text{Im}(f)\) (this is just the first isomorphism theorem). Thus, we <i>define</i> \(\text{Im}(f) = \text{Ker}(q)\).
</p>

<p>
<b>Definition 3.5</b> (Biproducts). Let \(\mathcal{C}\) be a category with zero morphisms. Let \(X_1, \dots, X_n\) be a collection of objects in \(\mathcal{C}\), a biproduct of
these objects is an object \(X_1 \oplus \cdots \oplus X_n\) and morphisms \(p_k : X_1 \oplus \cdots \oplus X_n \rightarrow X_k\) (projections) and \(i_k : X_k \rightarrow X_1 \oplus \cdots \oplus X_n\) (embeddings) which satisfy:
</p>

<ul class="org-ul">
<li>\(p_k \circ i_k = 1_k\), the identity arrow on \(X_k\)</li>
<li>\(p_{\ell} \circ i_k = 0_{k \ell}\), the zero morphism from \(X_k\) to \(X_{\ell}\).</li>
</ul>

<p>
In addition, we require that \((X_1 \oplus \cdots \oplus X_n, p_k)\) is a product of the objects \(X_k\) and that \((X_1 \oplus \cdots \oplus X_n, i_k)\) is a coproduct.
</p>

<p>
<b>Definition 3.6.</b> A morphism \(f : X \rightarrow Y\) is said to be a monomorphism if \(f \circ g = f \circ h\) implies \(g = h\) for any arrows \(g\) and \(h\).
A morphism is said to be an epimorphism if \(g \circ f = h \circ f\) implies \(g = h\) for any \(g\) and \(h\). A monomorphism is said to be <i>normal</i>
if it is the kernel of some morphism. An epimorphism is said to be <i>conormal</i> if it is the cokernel of some morphism.
</p>

<p>
We can now (finally) define Abelian categories:
</p>

<p>
<b>Definition 3.7</b> (Abelian category). An Abelian category \(\mathcal{C}\) is a preadditive category which satisfies the following criteria:
</p>

<ul class="org-ul">
<li>\(\mathcal{C}\) has a zero object.</li>
<li>\(\mathcal{C}\) contains all binary biproducts (i.e. biproducts of two objects, thus biproducts of a finite number of objects).</li>
<li>\(\mathcal{C}\) contains all kernels and cokernels.</li>
<li>Every monomorphism in \(\mathcal{C}\) is normal, every epimorphism is conormal.</li>
</ul>

<p>
Operating in the realm of Abelian categories allows us to prove many, generic results, some of which are recognizable from basic algebra.
</p>

<p>
<b>Definition 3.8.</b> If \(\mathcal{C}\) is an Abelian category, a sequence of morphisms indexed by integers \(\cdots \rightarrow X^{j - 1} \rightarrow X^j \rightarrow X^{j + 1} \rightarrow \cdots\)
is said to be a cochain complex if the composition of neighbouring arrows is the unique zero morphism between the objects. A chain complex is exactly the dualized version of the chain
complex that we would expect.
</p>

<p>
<b>Definition 3.9</b> (Cohomology and homology). We will focus here on the case of cohomology, rather than homology, as for our purposes, it is more important.
Let \(\mathcal{C}\) be an Abelian category, consider a cochain complex
</p>


<div id="org92bcd0c" class="figure">
<p><img src="./assets/cochain.png" alt="cochain.png" width="350px" />
</p>
</div>

<p>
which we denote by \(X^{\bullet}\), where we have \(d^{j + 1} \circ d^j : X^j \rightarrow X^{j + 2}\) equal to the zero morphism from \(X^j\) to \(X^{j + 2}\).
Of course, the data of \(\text{Ker}(d^j)\) is an object \(K^j\) and a map \(i^j : K \rightarrow X^j\) (and inclusion arrow). We then define \(u^j\) via the universal property which \(i^j\) and \(K^j\) satisfy:
</p>


<div id="orgdc4fe53" class="figure">
<p><img src="./assets/universal_co.png" alt="universal_co.png" width="250px" />
</p>
</div>

<p>
One should think of this arrow as restricting the target of \(d^{j - 1}\) to the kernel \(K^j\), as due to the fact that \(d^j \circ d^{j - 1}\) is the zero morphism, it makes sense
to do this. From here, we take \(H^j(X^{\bullet}) = \text{Coker}(u^j)\): this is the \(j\) -th cohomology of \(X^{\bullet}\). Informally, one can think of this as "the kernel of \(d^j\)
modulo the image of \(d^{j - 1}\)", which is the standard definition of cohomology when working with Abelian groups. In addition, if we have a collection of morphisms between terms of
cochain complexes \(X^{\bullet}\) and \(Y^{\bullet}\), \(f^j : X^j \rightarrow Y^j\),
</p>


<div id="org7dd368c" class="figure">
<p><img src="./assets/co_morphism.png" alt="co_morphism.png" width="400px" />
</p>
</div>

<p>
such that each of the squares in the above diagram commute, then we are able to define \(H^{j}(f^{\bullet}) : H^j(X^{\bullet}) \rightarrow H^{j}(Y^{\bullet})\) as follows.
We first define map from \(K_X^j\) to \(Q_Y^j\), where \(Q_Y^j\) is the object of \(H^j(Y^{\bullet})\). Of course, we have \(f^j : X^j \rightarrow Y^j\), and we have inclusion \(i^j_X : K_X^j \rightarrow X^j\),
so we have arrow \(f^j \circ i^j_X\). We then obtain unique map \(\widetilde{f} : K_X^j \rightarrow K_Y^j\) given by
</p>


<div id="org80af234" class="figure">
<p><img src="./assets/uni_2.png" alt="uni_2.png" width="250px" />
</p>
</div>

<p>
where it is obvious what the arrows should be, and we are using the fact that
</p>

\begin{equation}
d_Y^j \circ f^j \circ i_X^j = f^{j + 1} \circ d_X^{j + 1} \circ i_X^j = 0
\end{equation}

<p>
<b>Lemma 3.1.</b> If \(\mathcal{C}\) is an Abelian category, with arrows \(f : X \rightarrow Y\) and \(g : Y \rightarrow Z\) such that \(\text{Im}(f) \simeq \text{Ker}(g)\), then \(\text{Im}(g) \simeq \text{Coker}(f)\).
</p>

<p>
<i>Proof.</i> This amounts to showing that \(\text{Coker}(f) \simeq \text{Coker}(i_g)\), where \(i_g : \text{Ker}(g) \rightarrow Y\) is the defining map of \(\text{Ker}(g)\).
We know that \(\text{Im}(f) \simeq \text{Ker}(g)\), so we let \(q_f : X \rightarrow \text{Coker}(f)\) be the defining map for \(\text{Coker}(f)\), and then let \(i_{q_f} : \text{Ker}(q_f) \rightarrow X\)
be the defining map for \(\text{Ker}(q_f)\). Let \(\Phi : \text{Ker}(q_f) \rightarrow \text{Ker}(g)\) be an isomorphism (which we know exists). We define maps \(\phi\) and \(\psi\) via the universal properties of kernels of cokernels:
</p>


<div id="org465aac8" class="figure">
<p><img src="./assets/first_com.png" alt="first_com.png" width="400px" />
</p>
</div>

<p>
In particular, \(\phi\) and \(\psi\) are the unique arrows making the following diagrams commute:
</p>


<div id="org3083a90" class="figure">
<p><img src="./assets/com_2.png" alt="com_2.png" width="500px" />
</p>
</div>

<p>
Note that
</p>

\begin{align}
   q_{i_g} \circ f = q_{i_g} \circ i_{q_f} \circ \phi = q_{i_g} \circ i_g \circ \Phi \circ \phi = 0
\end{align}

<p>
and
</p>

\begin{align}
    q_{f} \circ i_g = q_f \circ i_{q_f} \circ \Phi^{-1} = 0
\end{align}

<p>
We can then fill in the dashed lines by again exploiting universal properties:
</p>


<div id="orgae84c7d" class="figure">
<p><img src="./assets/com_3.png" alt="com_3.png" width="500px" />
</p>
</div>

<p>
and it follows by uniqueness of \(\mu\) and \(\nu\) that they must be inverse of each other (thus definining an isomorphism of \(\text{Coker}(f)\) and \(\text{Coker}(i_g) = \text{Im}(g)\), as desired.
</p>

<p>
<b>Lemma 3.2</b> (Splitting lemma).
</p>
</div>
</div>

<div id="outline-container-org8e0363f" class="outline-2">
<h2 id="org8e0363f"><span class="section-number-2">4.</span> Derived functors</h2>
<div class="outline-text-2" id="text-4">
<p>
Now that we've cleared up the preliminaries, let us dive into the theory of derived functors. We will follow some nice <a href="https://www.math.toronto.edu/%7Ejacobt/Lecture12.pdf">lecture notes</a> prepared by Jacob Tsimerman for a course on etale cohomology, filling in details.
Within Abelian categories, one has a well-defined notion of a short exact sequence. In particular, we say that the sequence of morphisms in category \(\mathcal{C}\),
</p>


<div id="orge5c0ad6" class="figure">
<p><img src="./assets/short_exact.png" alt="short_exact.png" width="350px" />
</p>
</div>

<p>
is short exact if \(f\) is a monomorphism, \(g\) is an epimorphism, and \(\text{Im}(f) \simeq \text{Ker}(g)\) (they are isomorphic in the appropriate comma category). We then say that a functor \(F : \mathcal{C} \rightarrow \mathcal{D}\)
is <i>exact</i> if, for any short exact sequence of the above form, then
</p>


<div id="org53155ad" class="figure">
<p><img src="./assets/F_short_exact.png" alt="F_short_exact.png" width="350px" />
</p>
</div>

<p>
is also a short exact sequence. It is called left-exact (right-exact) under the weaker condition that we no longer require \(F(g)\) (\(F(f)\)) to be an epimorphism (monomorphism).
The main idea of a derived functor is to take a left-exact functor \(F\), and product a new family of functors (\(R^i F\) for \(i \geq 0\), where  \(R^0 F = F\)) which fit into a long exact sequence. This sequence can be thought of as
a "higher-order artifact" which quantifies the failure of a left-exact functor to be exact, which is a stronger condition.
</p>

<p>
Suppose we <i>did</i> have such functors:
</p>

\begin{equation}
    0 \to F(X) \to F(Y) \to F(Z) \to R^1 F(X) \to R^1 F(Y) \to R^1 F(Z) \to R^2 F(X) \to \cdots
\end{equation}

<p>
Let us try to deduce some necessary properties.
</p>

<p>
<b>Definition 4.1.</b> If \(\mathcal{C}\) is a category, we say that object \(I \in \mathcal{C}\) is injective if for every monomorphism \(f : X \rightarrow Y\)
and morphism \(g : X \rightarrow Q\), there exists morphism \(h : Y \rightarrow Q\) extending \(g\) (i.e. \(h \circ f = g\)).
We say that \(\mathcal{C}\) has <i>enough injectives</i> if for every object \(X\) in \(\mathcal{C}\), there is a monomorphism \(X \rightarrow I\) from \(X\) into some injective object.
</p>

<p>
Suppose \(I\) is injective in Abelian category \(\mathcal{C}\) and suppose we have short exact sequence \(0 \to I \to X \to Y \to 0\) (with arrows \(f\) and \(g\)). The fact that \(I\) is injective means that
there must be \(h\) such that \(h \circ f = \text{id}_I\), so \(f\) has a left-inverse, which means (via the splitting lemma) that \(X \simeq I \oplus Y\) (the biproduct of \(I\) and \(Y\)) via the arrow \(k\):
</p>


<div id="org852350d" class="figure">
<p><img src="./assets/splitting_lemma.png" alt="splitting_lemma.png" width="450px" />
</p>
</div>

<p>
We want to show that \(F(g)\) is an epimorphism. We have the inclusion and projection to and from the biproduct, \(Y \to I \oplus Y \to Y\), which compose to give the identity.
It follows that \(F(p \circ j) = F(p) \circ F(j) = \text{id}\), so \(F(p)\) has a right-inverse, which automatically implies it is an epimorphism. Hence, \(F(g)\) is as well, as \(F(k)\) is an isomorphism.
Therefore, the left-exact functor actually takes the short exact sequence to a true, exact sequence. This means that we can extend the short exact sequence to a long exact sequence trivially: we just keep adding zeros.
This extension isn't unique, we could have any sequence which looks like:
</p>

\begin{equation}
    0 \to F(I) \to F(X) \to F(Y) \to 0 \to R^1 F(X) \simeq R^1 F(Y) \to 0 \to R^2 F(X) \simeq R^2 F(Y) \to 0 \to \cdots
\end{equation}

<p>
and we would still have exactness. However, in any of these cases, we have \(R^i F(I) = 0\) for \(i \geq 1\) when \(I\) is an injective object. This suggests to us that, perhaps, our functors \(R^i F\) should kill all injective
objects when \(i \geq 1\). As it turns out, this intuition is correct, and will guide us towards the definition of \(R^i F\).
</p>

<p>
Suppose we are working in Abelian category \(\mathcal{C}\) which has enough injectives. Given some object \(X\), let us pick some monomorphism \(f : X \rightarrow I\). We then note that \(Y = \text{Coker}(f)\) is in \(\mathcal{C}\),
so we have short exact sequence \(0 \to X \to I \to Y \to 0\). From here, assume that we have \(R^i F(I) = 0\) for \(i \geq 1\). The associated long exact sequence (if it exists) will look like
</p>

\begin{equation}
    0 \to F(X) \to F(I) \to F(Y) \to R^1 F(X) \to 0 \to R^1 F(Y) \to R^2 F(X) \to 0 \to \cdots
\end{equation}

<p>
which means that \(R^1 F(X)\) is the image of \(F(Y) \to R^1 F(X)\), which is isomorphic to the cokernel of \(F(I) \to F(Y)\). In addition, we have \(R^{i - 1} F(Y) \simeq R^i F(X)\) for \(i \geq 2\). This means that we should
be able to compute \(R^2 F(X)\), for example, by embedding \(Y\) in an injective \(J\), \(g : Y \rightarrow J\), and then computing \(R^1 F(Y)\) by computing the cokernel of \(F(J) \to F(Z)\), where \(Z = \text{Coker}(g)\). We can repeat
this procedure recursively to get all higher \(R^i F(X)\). Of course, to do this, we need the guarantee that we can actually embed into injective objects in the first place:
this is precisely the condition of our category having ``enough injectives", which we introduced earlier. It is also unclear at this point that the \(R^i F(X)\) will be independent of the injective embeddings chosen: we will soon show that this is the case.
</p>
</div>
</div>

<div id="outline-container-orgd9e6454" class="outline-2">
<h2 id="orgd9e6454"><span class="section-number-2">5.</span> Derived categories</h2>
</div>

<div id="outline-container-org2996454" class="outline-2">
<h2 id="org2996454"><span class="section-number-2">6.</span> Sheaf cohomology and hypercohomology</h2>
</div>

<div id="outline-container-org1ea3a7b" class="outline-2">
<h2 id="org1ea3a7b"><span class="section-number-2">7.</span> Hochschild homology and cohomology</h2>
<div class="outline-text-2" id="text-7">
<p>
As a final (fun) application of the theory of derived functors and derived categories, let us discuss a very natural formulation of Hochschild homology and cohomology for algebras over rings.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jack Ceroni</p>
<p class="date">Created: 2025-08-11 Mon 13:41</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
