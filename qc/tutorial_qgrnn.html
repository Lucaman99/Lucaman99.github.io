
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="Using a quantum graph recurrrent neural network to learn quantum dynamics." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/qgrnn_thumbnail.png" property="og:image" />

  

  <meta property="og:title" content="The Quantum Graph Recurrrent Neural Network &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_qgrnn.html">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Using a quantum graph recurrrent neural network to learn quantum dynamics." name="description" />
  

  <link href="https://fonts.googleapis.com/css?family=Noto+Serif" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">

  <!-- Material Design Bootstrap -->
  <!-- <link href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/css/mdb.min.css" rel="stylesheet"> -->

  <!-- nanoscroller -->
  <link rel="stylesheet" type="text/css" href="../_static/css/nanoscroller.css" />

  <!-- lightslider -->
  <link type="text/css" rel="stylesheet" href="../_static/css/lightslider.min.css" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       SVG: { linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           bm: ['\\mathbf{\#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['I',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           diag: ['\\mathrm{diag} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0]
         }
       }
     });
     </script>
      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-130507810-1');
      </script>

  <title>The Quantum Graph Recurrrent Neural Network &#8212; PennyLane</title>
  
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/xanadu_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-dataframe.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_qgrnn.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body><link rel="stylesheet" type="text/css" href="../_static/xanadu_gallery.css" />
  <!--Navbar-->
<nav class="navbar navbar-expand-lg navbar-light white sticky-top">

  <!-- Navbar brand -->
  <a class="navbar-brand" href="https://pennylane.ai">
    <img class="pr-1" src="../_static/xanadu_x.png" width="28px"></img>
    <img src="../_static/pennylane.png" width="180px"></img>
  </a>

  <!-- Collapse button -->
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
    aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <!-- Collapsible content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links -->
    <ul class="navbar-nav mr-auto">
      <li class="nav-item active">
        <a class="nav-link" href="https://pennylane.ai/qml">Quantum machine learning
          <span class="sr-only">(current)</span>
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://pennylane.ai/install.html">Install</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://pennylane.ai/plugins.html">Plugins</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://pennylane.readthedocs.io">Documentation</a>
      </li>
    </ul>
    <!-- Links -->

    <ul class="navbar-nav ml-auto nav-flex-icons">
      <li class="nav-item">
        <a class="nav-link" href="http://pennylane.ai/faq.html">
          <i class="fab fas fa-question"></i> FAQ
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://discuss.pennylane.ai">
          <i class="fab fab fa-discourse"></i> Support
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://github.com/XanaduAI/PennyLane">
          <i class="fab fa-github"></i> GitHub
        </a>
      </li>
    </ul>
  </div>
  <!-- Collapsible content -->
</nav>
<!--/.Navbar-->
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li> 
      </ul>
    </div>
        <div id="content">


          <div id="right-column">
            <div class="document clearer body">

              <div class="container-wrapper">

                <div role="navigation" aria-label="breadcrumbs navigation">
                  <ol class="breadcrumb">
                  </ol>
                </div>

              
  <div class="sphx-glr-download-link-note admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-qgrnn-py"><span class="std std-ref">here</span></a>     to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="the-quantum-graph-recurrrent-neural-network">
<span id="sphx-glr-demos-tutorial-qgrnn-py"></span><h1>The Quantum Graph Recurrrent Neural Network<a class="headerlink" href="#the-quantum-graph-recurrrent-neural-network" title="Permalink to this headline">¶</a></h1>
<p><em>Author: Jack Ceroni</em></p>
<p>In this demonstration, we investigate the idea of a quantum graph
recurrent neural network (QGRNN), which is the quantum analogue of a
classical graph recurrent neural network and a subclass of the more
general quantum graph
neural network ansatz (<a class="reference external" href="https://arxiv.org/abs/1909.12264">QGNN</a>).</p>
<div class="section" id="the-idea">
<h2>The Idea<a class="headerlink" href="#the-idea" title="Permalink to this headline">¶</a></h2>
<p>A graph is defined as a set of <strong>nodes</strong>, along with a set of
<strong>edges</strong>, which represent interactions or relationships between nodes.
Sometimes, we like to encode information into graphs by assigning numbers
to nodes and edges, which we call <strong>weights</strong>.
It is usually convenient to think of a graph visually:</p>
<a class="reference internal image-reference" href="../_images/graph.png"><img alt="../_images/graph.png" class="align-center" src="../_images/graph.png" style="width: 70%;" /></a>
<p>In recent years, the concept of a
<a class="reference external" href="https://arxiv.org/abs/1812.08434">graph neural network</a> (GNN) has been
receving a lot of attention from the machine learning community.
A GNN seeks
to learn a representation (a mapping of data into a
lower-dimensional vector space) of a given graph with features assigned
to nodes and edges. Each of the vectors in the learned
representation preserves not only the features, but also the overall
topology of the graph, i.e., which nodes are connected by edges. The
quantum graph neural network attempts to do something similar, but for
features that are quantum-mechanical; for instance, a
collection of quantum states.</p>
<p>Consider the class of qubit Hamiltonians that are <em>quadratic</em>, meaning that
the terms of the Hamiltonian represent either interactions between two
qubits, or the energy of individual qubits.
This class of Hamiltonians is naturally described by graphs, with
second-order terms between qubits corresponding to weighted edges between
nodes, and first-order terms corresponding to node weights.</p>
<p>A well known example of a quadratic Hamiltonian is the transverse
field Ising model, which is defined as</p>
<div class="math notranslate nohighlight">
\[\hat{H}_{\text{Ising}}(\boldsymbol\theta) \ = \ \displaystyle\sum_{(i, j) \in E} \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \ \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \ \displaystyle\sum_{i} X_{i},\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol\theta \ = \ \{\theta^{(1)}, \ \theta^{(2)}\}\)</span>.
In this Hamiltonian, the set <span class="math notranslate nohighlight">\(E\)</span> that determines which pairs of qubits
have <span class="math notranslate nohighlight">\(ZZ\)</span> interactions is exactly the set of edges for some graph. With
the qubits as nodes we call this graph the <em>interaction graph</em>.
The <span class="math notranslate nohighlight">\(\theta^{(1)}\)</span> parameters correspond to the edge weights and
the <span class="math notranslate nohighlight">\(\theta^{(2)}\)</span>
parameters correspond to weights on the nodes.</p>
<p>This result implies that we can think about <em>quantum circuits</em> with
graph-theoretic properties. Recall that the time-evolution operator
with respect to some Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[U \ = \ e^{-it H}.\]</div>
<p>Thus, we have a clean way of taking graph-theoretic Hamiltonians and turning
them into unitaries (quantum circuits) that preserve the same correspondance to a graph.
In the case of the Ising Hamiltonian, we have:</p>
<div class="math notranslate nohighlight">
\[U_{\text{Ising}} \ = \ e^{-it \hat{H}_{\text{Ising}} (\boldsymbol\theta)} \ = \ \exp \Big[ -it \Big( \displaystyle\sum_{(i, j) \in E} \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \ \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \ \displaystyle\sum_{i} X_{i} \Big) \Big]\]</div>
<p>In general, this kind of unitary is very difficult to implement on a quantum computer,
but luckily, we can approximate it using the <a class="reference external" href="https://en.wikipedia.org/wiki/Time-evolving_block_decimation#The_Suzuki-Trotter_expansion">Trotter-Suzuki decomposition</a>:</p>
<div class="math notranslate nohighlight">
\[\exp \Big[ -it \Big( \displaystyle\sum_{(i, j) \in E} \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \ \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \ \displaystyle\sum_{i} X_{i} \Big) \Big]
\ \approx \ \displaystyle\prod_{k \ = \ 1}^{t / \Delta} \Bigg[ \displaystyle\prod_{j \ = \ 1}^{Q} e^{-i \Delta \hat{H}_{\text{Ising}}^{j}(\boldsymbol\theta)} \Bigg]\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{H}_{\text{Ising}}^{j}(\boldsymbol\theta)\)</span> is the <span class="math notranslate nohighlight">\(j\)</span>-th term of the
Ising Hamiltonian. <span class="math notranslate nohighlight">\(\Delta\)</span> is some small number.</p>
<p>The circuit at which we have arrived is a specific instance of the <strong>Quantum Graph
Recurrent Neural Network</strong>, which in general is defined as a variational ansatz of
the form</p>
<div class="math notranslate nohighlight">
\[U_{H}(\boldsymbol\mu, \ \boldsymbol\gamma) \ = \ \displaystyle\prod_{i \ = \ 1}^{P} \Bigg[ \displaystyle\prod_{j \ = \ 1}^{Q} e^{-i \gamma_j H^{j}(\boldsymbol\mu)} \Bigg],\]</div>
<p>for some parametrized Hamiltonian, <span class="math notranslate nohighlight">\(H(\boldsymbol\mu)\)</span>, of
quadratic order.</p>
<div class="section" id="using-the-qgrnn">
<h3>Using the QGRNN<a class="headerlink" href="#using-the-qgrnn" title="Permalink to this headline">¶</a></h3>
<p>Since the QGRNN ansatz is equivalent to the
approximate time evolution of some quadratic Hamiltonian, we can use it
to learn the dynamics of a quantum system.</p>
<p>Continuing on with the Ising model example, let’s imagine we have some system
governed by <span class="math notranslate nohighlight">\(\hat{H}_{\text{Ising}}(\boldsymbol\alpha)\)</span> for an unknown set of
target parameters,
<span class="math notranslate nohighlight">\(\boldsymbol\alpha\)</span> and an unknown interaction graph <span class="math notranslate nohighlight">\(G\)</span>. Let’s also
suppose we have access to a bunch of copies of some
low-energy state with respect to the target Hamiltonian, <span class="math notranslate nohighlight">\(|\psi_0\rangle\)</span>. In addition,
we have access to a collection of time evolved states,
<span class="math notranslate nohighlight">\(\{ |\psi(t_1)\rangle, \ |\psi(t_2)\rangle, \ ..., \ |\psi(t_N)\rangle \}\)</span>, defined by:</p>
<div class="math notranslate nohighlight">
\[|\psi(t_k)\rangle \ = \ e^{-i t_k \hat{H}_{\text{Ising}}(\boldsymbol\alpha)} |\psi_0\rangle\]</div>
<p>We call the low-energy states, and the collection of time-evolved states <em>quantum data</em>.
From here, we randomly pick a given number of time-evolved states
from our collection. For some state that we choose, which is
evolved to some arbitrary time <span class="math notranslate nohighlight">\(t_k\)</span>, we compare it
to</p>
<div class="math notranslate nohighlight">
\[U_{\hat{H}_{\text{Ising}}}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle \ \approx \ e^{-i t_k \hat{H}_{\text{Ising}}(\boldsymbol\mu)} |\psi_0\rangle\]</div>
<p>by feeding one of the copies of <span class="math notranslate nohighlight">\(|\psi_0\rangle\)</span> into a quantum circuit
with the QGRNN ansatz, with some “guessed” set of parameters <span class="math notranslate nohighlight">\(\boldsymbol\mu\)</span>
and a guessed interaction graph, <span class="math notranslate nohighlight">\(G'\)</span>.
We then use a classical optimizer to maximize the average
“similarity” between the time-evolved states and the states prepared
with the QGRNN.</p>
<p>As the QGRNN states becomes more “similar” to
each time-evolved state for each sampled time, it follows that
<span class="math notranslate nohighlight">\(\boldsymbol\mu \ \rightarrow \ \boldsymbol\alpha\)</span>
and we are able to learn the unknow parameters of the Hamiltonian.</p>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="../_images/qgrnn3.png"><img alt="../_images/qgrnn3.png" src="../_images/qgrnn3.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text">A visual representation of one execution of the QGRNN for one piece of quantum data</span></p>
</div>
</div>
</div>
<div class="section" id="learning-an-ising-model-with-the-qgrnn">
<h2>Learning an Ising Model with the QGRNN<a class="headerlink" href="#learning-an-ising-model-with-the-qgrnn" title="Permalink to this headline">¶</a></h2>
<p>Keeping in form with the introduction, we now attempt to learn the parameters corresponding
to some arbitrary transverse field Ising model Hamiltonian,
using the QGRNN.</p>
<div class="section" id="getting-started">
<h3>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h3>
<p>We begin by importing the necessary dependencies:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
</pre></div>
</div>
<p>We can then define some fixed values that are used throughout
the simulation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qubit_number</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to use the QGRNN, we need access to quantum data. In this
simulation, we don’t have quantum data readily available to pass into
the QGRNN, so we have to generate it ourselves. To do this, we must
have knowledge of the target interaction graph and the target Hamiltonian.</p>
<p>We first define the target interaction graph
of the Ising Hamiltonian to be the cycle graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ising_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ising_graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edges: </span><span class="si">{}</span><span class="s2">&quot;</span> <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ising_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
</pre></div>
</div>
<p>We then can initialize the “unknown” target parameters that describe the
target Hamiltonian, <span class="math notranslate nohighlight">\(\boldsymbol\alpha \ = \ \{\alpha^{(1)}, \ \alpha^{(2)}\}\)</span>.
Recall from the introduction that we have defined our parametrized
Ising Hamiltonian to be of the form:</p>
<div class="math notranslate nohighlight">
\[\hat{H}_{\text{Ising}}(\boldsymbol\theta) \ = \ \displaystyle\sum_{(i, j) \in E} \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \ \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \ \displaystyle\sum_{i} X_{i},\]</div>
<p>where <span class="math notranslate nohighlight">\(E\)</span> is the set of edges in the interaction graph, and
<span class="math notranslate nohighlight">\(X_i\)</span> and <span class="math notranslate nohighlight">\(Z_i\)</span> are the Pauli-X and Pauli-Z on the
<span class="math notranslate nohighlight">\(i\)</span>-th qubit.</p>
<p>For this tutorial, we choose the target parameters manually.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">matrix_params</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.58</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.77</span><span class="p">,</span> <span class="mf">0.83</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.82</span><span class="p">,</span> <span class="mf">0.17</span><span class="p">,</span> <span class="mf">0.14</span><span class="p">]]</span>
</pre></div>
</div>
<p>In theory, these parameters can
be any value we want, provided they are reasonbly small enough that the QGRNN can reach them
in a tractable number of optimization steps.
The first list represents the <span class="math notranslate nohighlight">\(ZZ\)</span> interaction parameters and
the second list represents the single-qubit <cite>Z</cite> parameters.</p>
<p>Finally,
we use this information to generate the matrix form of the
Ising model Hamiltonian in the computational basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_hamiltonian_matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>

    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">))</span>

    <span class="c1"># Creates the interaction component of the Hamiltonian</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># Creates the bias components of the matrix</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">matrix</span>

<span class="c1"># Prints a visual representation of the Hamiltonian matrix</span>
<span class="n">ham_matrix</span> <span class="o">=</span> <span class="n">create_hamiltonian_matrix</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">,</span> <span class="n">ising_graph</span><span class="p">,</span> <span class="n">matrix_params</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">ham_matrix</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="preparing-quantum-data">
<h3>Preparing Quantum Data<a class="headerlink" href="#preparing-quantum-data" title="Permalink to this headline">¶</a></h3>
<p>The collection of quantum data needed to run the QGRNN has two componenets:
copies of a low-energy state, and a collection of time-evolved state, each of which are
simply the low-energy state evolved to different times.
For the target Hamiltonian we
defined, we find that a low-energy state is given by the following vector
(represented by a Numpy array):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">low_energy_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.02086666</span><span class="o">+</span><span class="mf">0.00920016</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.00379192</span><span class="o">-</span><span class="mf">0.00859852</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.06594626</span><span class="o">-</span><span class="mf">0.02907913</span><span class="n">j</span><span class="p">,</span>
  <span class="mf">0.0119852</span> <span class="o">+</span><span class="mf">0.02717445</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.07633593</span><span class="o">-</span><span class="mf">0.03366391</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.01387486</span><span class="o">+</span><span class="mf">0.03145572</span><span class="n">j</span><span class="p">,</span>
 <span class="o">-</span><span class="mf">0.24124938</span><span class="o">+</span><span class="mf">0.10640219</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.04385454</span><span class="o">-</span><span class="mf">0.09941154</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.06397641</span><span class="o">-</span><span class="mf">0.02820407</span><span class="n">j</span><span class="p">,</span>
  <span class="mf">0.01162454</span><span class="o">+</span><span class="mf">0.02636273</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.20218878</span><span class="o">+</span><span class="mf">0.08914518</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03674192</span><span class="o">-</span><span class="mf">0.08331586</span><span class="n">j</span><span class="p">,</span>
 <span class="o">-</span><span class="mf">0.23404312</span><span class="o">+</span><span class="mf">0.10320031</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.04253486</span><span class="o">-</span><span class="mf">0.09644206</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.73966164</span><span class="o">-</span><span class="mf">0.32618732</span><span class="n">j</span><span class="p">,</span>
  <span class="mf">0.13444079</span><span class="o">+</span><span class="mf">0.30479209</span><span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
<p>We can verify that this is a low-energy
state by numerically finding the lowest eigenvalue of the Hamiltonian
matrix and comparing it to the energy expectation of the low-energy state:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Finds the energy expectation</span>

<span class="k">def</span> <span class="nf">expectation_value</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">vector</span><span class="p">),</span> <span class="p">(</span><span class="n">matrix</span> <span class="o">@</span> <span class="n">vector</span><span class="p">))</span>

<span class="n">energy_exp</span> <span class="o">=</span> <span class="n">expectation_value</span><span class="p">(</span><span class="n">low_energy_state</span><span class="p">,</span> <span class="n">ham_matrix</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energy Expectation: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">energy_exp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">ground_state_energy</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>

    <span class="c1"># Finds the eigenstates of the matrix</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">matrix</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Returns the minimum eigenvalue</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

<span class="n">ground_state</span> <span class="o">=</span> <span class="n">ground_state_energy</span><span class="p">(</span><span class="n">ham_matrix</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ground State Energy: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ground_state</span><span class="p">))</span>
</pre></div>
</div>
<p>This shows us that we have in fact found a low-energy, non-ground state,
as the energy expectation is slightly greater than the energy of the true ground
state. This, however, is only half of the information we need. We also require
a collection of time-evolved states.
Luckily, evolving a state forward in time is fairly straightforward, all we
have to do is multiply the initial state by a time-evolution unitary. We define
this operation as a custom gate in PennyLane:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">state_evolve</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">hamiltonian</span> <span class="o">*</span> <span class="n">time</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">qubits</span><span class="p">)</span>
</pre></div>
</div>
<p>We don’t actually generate this time-evolved quantum data quite yet,
but we now have all the pieces required for its preparation.</p>
</div>
<div class="section" id="learning-the-hamiltonian">
<h3>Learning the Hamiltonian<a class="headerlink" href="#learning-the-hamiltonian" title="Permalink to this headline">¶</a></h3>
<p>With the quantum data defined, we are able to construct the QGRNN and
learn the target Hamiltonian. As was discussed above, we wish to use the
QGRNN to approximate time-evolution of the target Hamiltonian, with
guessed parameters. It follows that we let each of the three
<span class="math notranslate nohighlight">\(\hat{H}_{q}(\boldsymbol\mu)\)</span> used in the QGRNN ansatz be the
collections of <span class="math notranslate nohighlight">\(ZZ\)</span>, <span class="math notranslate nohighlight">\(Z\)</span>, and <span class="math notranslate nohighlight">\(X\)</span> terms from the Ising
Hamiltonian. This gives us:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qgrnn_layer</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">trotter</span><span class="p">):</span>

    <span class="c1"># Applies a layer of coupling gates (based on a graph)</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">MultiRZ</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">param1</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">*</span> <span class="n">trotter</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="c1"># Applies a layer of RZ gates</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">param2</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">*</span> <span class="n">trotter</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># Applies a layer of RX gates</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">RX</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">trotter</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>As was mentioned in the first section, the QGRNN has two qubit
registers. In one register, some piece of quantum data
<span class="math notranslate nohighlight">\(|\psi(t)\rangle\)</span> is prepared and in the other we have
<span class="math notranslate nohighlight">\(U_{H}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle\)</span>. We need a
way to measure the similarity between these states.
One way that we can do this is by using the fidelity, which is
simply the modulus squared of the inner product between the states,
<span class="math notranslate nohighlight">\(| \langle \psi(t) | U_{H}(\Delta, \ \boldsymbol\mu) |\psi_0\rangle |^2\)</span>.
To calculate this value, we utilize a <a class="reference external" href="https://en.wikipedia.org/wiki/Swap_test">SWAP
test</a> between the registers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">swap_test</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">register1</span><span class="p">,</span> <span class="n">register2</span><span class="p">):</span>

    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">control</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">register1</span><span class="p">)):</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">CSWAP</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">control</span><span class="p">),</span> <span class="n">register1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">register2</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">control</span><span class="p">)</span>
</pre></div>
</div>
<p>Before creating the full QGRNN and the cost function, we
define a few more fixed values. Among these fixed values is a “guessed”
interaction graph, which we define to be the complete graph. This choice
is motivated by the fact that any target interaction graph will be a subgraph
of this initial guess.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Defines some fixed values</span>

<span class="n">reg1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">))</span>  <span class="c1"># First qubit register</span>
<span class="n">reg2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qubit_number</span><span class="p">))</span>  <span class="c1"># Second qubit register</span>

<span class="n">control</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qubit_number</span>  <span class="c1"># Index of control qubit</span>
<span class="n">trotter_step</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># Trotter step size</span>

<span class="c1"># Defines the interaction graph for the new qubit system</span>

<span class="n">new_ising_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">new_ising_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qubit_number</span><span class="p">))</span>
<span class="n">new_ising_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)])</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edges: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_ising_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">new_ising_graph</span><span class="p">)</span>
</pre></div>
</div>
<p>Part of the idea behind the QGRNN is that
we don’t know the interaction graph, and it has to be learned. In this case, the graph
is learned <strong>automatically</strong> as the target parameters are learned. The
<span class="math notranslate nohighlight">\(\boldsymbol\mu\)</span> parameters that correspond to edges that don’t exist in
the target graph will simply approach <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>With this done, we implement the QGRNN circuit for some given time value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qgrnn</span><span class="p">(</span><span class="n">params1</span><span class="p">,</span> <span class="n">params2</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="c1"># Prepares the low energy state in the two qubit registers</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">low_energy_state</span><span class="p">,</span> <span class="n">low_energy_state</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="n">reg1</span><span class="o">+</span><span class="n">reg2</span><span class="p">)</span>

    <span class="c1"># Evolves the first qubit register with the time-evolution circuit, to prepare a piece of quantum data</span>
    <span class="n">state_evolve</span><span class="p">(</span><span class="n">ham_matrix</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>

    <span class="c1"># Applies the QGRNN layers to the second qubit register</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">time</span> <span class="o">/</span> <span class="n">trotter_step</span>  <span class="c1"># P = t/Delta</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">depth</span><span class="p">)):</span>
        <span class="n">qgrnn_layer</span><span class="p">(</span><span class="n">params1</span><span class="p">,</span> <span class="n">params2</span><span class="p">,</span> <span class="n">reg2</span><span class="p">,</span> <span class="n">new_ising_graph</span><span class="p">,</span> <span class="n">trotter_step</span><span class="p">)</span>

    <span class="c1"># Applies the SWAP test between the registers</span>
    <span class="n">swap_test</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span>

    <span class="c1"># Returns the results of the SWAP test</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="n">control</span><span class="p">))</span>
</pre></div>
</div>
<p>Notice how the value returned from the circuit is
<span class="math notranslate nohighlight">\(\langle Z \rangle\)</span>, with respect to the ancilla qubit. This is
because after performing a SWAP test between two states
<span class="math notranslate nohighlight">\(|\psi\rangle\)</span> and <span class="math notranslate nohighlight">\(|\phi\rangle\)</span>, it is tue that
<span class="math notranslate nohighlight">\(\langle Z \rangle \ = \ |\langle \psi | \phi \rangle|^2\)</span>.</p>
<p>We have the full QGRNN circuit, but we still need to define a cost
function to minimize. We know that
<span class="math notranslate nohighlight">\(| \langle \psi(t) | U_{H}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle |^2\)</span>
approaches <span class="math notranslate nohighlight">\(1\)</span> as the states become more similar, thus we choose
to minimize the quantity
<span class="math notranslate nohighlight">\(1 \ - \ | \langle \psi(t) | U_{H}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle |^2\)</span>.
Since we are interested in calculating this value for many different
pieces of quantum data, the final cost function is the <strong>average
infidelity</strong> between registers:</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\boldsymbol\mu, \ \Delta) \ = \ 1 \ - \ \frac{1}{N} \displaystyle\sum_{t \ = \ 1}^{N} | \langle \psi(t) | \ U_{H}(\boldsymbol\mu, \ \Delta) \ |\psi_0\rangle |^2,\]</div>
<p>where we use <span class="math notranslate nohighlight">\(N\)</span> pieces of quantum data.</p>
<p>Before creating the cost function, we must define a few more fixed
variables, the device, and the QNode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">15</span>  <span class="c1"># The number of pieces of quantum data that are used for each step</span>
<span class="n">max_time</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># The maximum value of time that can be used for quantum data</span>

<span class="c1"># Defines the new device</span>

<span class="n">qgrnn_dev</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">qubit_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Defines the new QNode</span>

<span class="n">qnode</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">QNode</span><span class="p">(</span><span class="n">qgrnn</span><span class="p">,</span> <span class="n">qgrnn_dev</span><span class="p">)</span>
</pre></div>
</div>
<p>We then define the infidelity cost function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cost_function</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>

    <span class="k">global</span> <span class="n">iterations</span>

    <span class="c1"># Separates the parameter list</span>
    <span class="n">weight_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">bias_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>

    <span class="c1"># Randomly samples times at which the QGRNN runs</span>
    <span class="n">times_sampled</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">()</span> <span class="o">*</span> <span class="n">max_time</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)]</span>

    <span class="c1"># Cycles through each of the sampled times and calculates the cost</span>
    <span class="n">total_cost</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">times_sampled</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">qnode</span><span class="p">(</span><span class="n">weight_params</span><span class="p">,</span> <span class="n">bias_params</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="n">total_cost</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">result</span>

    <span class="c1"># Prints the value of the cost function</span>
    <span class="k">if</span> <span class="n">iterations</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cost at Step &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iterations</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">total_cost</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">_value</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Parameters at Step &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iterations</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">_value</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---------------------------------------------&quot;</span><span class="p">)</span>

    <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">total_cost</span> <span class="o">/</span> <span class="n">N</span>
</pre></div>
</div>
<p>The last step is to define and execute the optimizer. We use Adam,
with a step-size of <span class="math notranslate nohighlight">\(0.3\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">AdamOptimizer</span><span class="p">(</span><span class="n">stepsize</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">steps</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">qgrnn_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="o">/</span> <span class="mi">50</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span>

<span class="c1"># Executes the optimization method</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
    <span class="n">qgrnn_params</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="n">qgrnn_params</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final Parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qgrnn_params</span><span class="p">))</span>
</pre></div>
</div>
<p>With the learned parameters, we construct a visual representation
of the Hamiltonian to which they correspond:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_ham_matrix</span> <span class="o">=</span> <span class="n">create_hamiltonian_matrix</span><span class="p">(</span>
    <span class="n">qubit_number</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">),</span> <span class="p">[</span><span class="n">qgrnn_params</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">],</span> <span class="n">qgrnn_params</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">]]</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">new_ham_matrix</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>In addition, we can construct a visual representation of the target
and learned parameters, to assess their similarity.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Creates the colour plot function</span>

<span class="k">def</span> <span class="nf">create_colour_plot</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Inserts 0s where there is no edge present in target parameters</span>

<span class="n">target_params</span> <span class="o">=</span> <span class="n">matrix_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">matrix_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">target_params</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">target_params</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Prints the colour plot of the parameters</span>

<span class="n">create_colour_plot</span><span class="p">([</span><span class="n">target_params</span><span class="p">,</span> <span class="n">qgrnn_params</span><span class="p">])</span>
</pre></div>
</div>
<p>The top row is the target values, while the bottom row is the learned
ones.
The similarity of colours indicates that the parameters are very
similar, which we can verify by looking at their exact values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Target parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_params</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Learned parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qgrnn_params</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="references">
<h1>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h1>
<ol class="arabic simple">
<li>Verdon, G., McCourt, T., Luzhnica, E., Singh, V., Leichenauer, S., &amp;
Hidary, J. (2019). Quantum Graph Neural Networks. arXiv preprint
<a class="reference external" href="https://arxiv.org/abs/1909.12264">arXiv:1909.12264</a>.</li>
</ol>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.000 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-qgrnn-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<a class="reference download internal" download="" href="../_downloads/e5fdae1e094154ad4aa2bfcf7cc8837d/tutorial_qgrnn.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_qgrnn.py</span></code></a></div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<a class="reference download internal" download="" href="../_downloads/f784a075b48e672678e2c85c4cbc44f1/tutorial_qgrnn.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_qgrnn.ipynb</span></code></a></div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>


              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_qgrnn</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>
            </div>
          </div>
              <div class="comment-container nano has-scrollbar">
  <div class="nano-content">
    
    <div id="comments">
      <h3>Contents</h3>
      <ul>
<li><a class="reference internal" href="#">The Quantum Graph Recurrrent Neural Network</a><ul>
<li><a class="reference internal" href="#the-idea">The Idea</a><ul>
<li><a class="reference internal" href="#using-the-qgrnn">Using the QGRNN</a></li>
</ul>
</li>
<li><a class="reference internal" href="#learning-an-ising-model-with-the-qgrnn">Learning an Ising Model with the QGRNN</a><ul>
<li><a class="reference internal" href="#getting-started">Getting Started</a></li>
<li><a class="reference internal" href="#preparing-quantum-data">Preparing Quantum Data</a></li>
<li><a class="reference internal" href="#learning-the-hamiltonian">Learning the Hamiltonian</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>

    </div>
    
    <div class="xanadu-call-to-action-links">
      <h3>Downloads</h3>
      <div id="tutorial-type">demos/tutorial_qgrnn</div>
      <div class="download-python-link">
        <i class="fab fa-python"></i>&nbsp;
        <div class="call-to-action-desktop-view">Download Python script</div>
      </div>
      <div class="download-notebook-link">
        <i class="fas fa-download"></i>&nbsp;
        <div class="call-to-action-desktop-view">Download Notebook</div>
      </div>
      <div class="github-view-link">
        <i class="fab fa-github"></i>&nbsp;
        <div class="call-to-action-desktop-view">View on GitHub</div>
      </div>
    </div>
  </div>
</div>
            

          <div class="up-button">
            
                <a href="../index.html"><i class="fas fa-angle-double-left"></i></a>
            
          </div>

          <div class="clearfix"></div>
        </div>


    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li> 
      </ul>
    </div>

    <!-- JQuery -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <!-- Bootstrap core JavaScript -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <!-- MDB core JavaScript -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
    <!-- Nanoscroller -->
    <script type="text/javascript" src="../_static/js/nanoscroller.min.js"></script>
    <script type="text/javascript">
        $('a.reference.external').each(function(){
          var link = $(this).attr("href");
          var hash = link.split('#')[1];
          var page = link.split('#')[0].split('/').slice(-1)[0].replace(".html", "");
          if (hash == page) {
            $(this).attr('href', link.split('#')[0]);
          }
        });
        $(".document > .section").removeClass("section");
        $(".comment-container .nano-content").css("height", $("#content").height());
        $(".comment-container").css("height", $("#content").height());
        $(".nano").nanoScroller();
    </script>
    <!-- lightslider -->
    <script src="../_static/js/lightslider.min.js"></script>

    <script type="text/javascript">
      $(".document > .section").removeClass("section");
      $(".nano").nanoScroller();
    </script>
    <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $('.comment-container').css("height", "calc(100% - " + (342 - scrollBottom + 119) + "px)");
          $('.comment-container .nano-content').css("height", "calc(100% - " + (342 - scrollBottom + 119) + "px)");
        }
      });
      $(document).ready(function () {
          $(".css-transitions-only-after-page-load").each(function (index, element) {
              setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
          });
      });
    </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "XanaduAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href,
          notebookDownloadPath = notebookLink.split('_downloads')[1].split('/').pop();

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            $("#featured-demos").lightSlider({
                item: 3,
                autoWidth: false,
                slideMove: 1, // slidemove will be 1 if loop is true
                slideMargin: 0,
                auto: true,
                loop: true,
                controls: true,
                pause: 5000,
                pager: false,
                prevHtml: "<i class='fas fa-chevron-left black-text' style='font-size: xx-large;'></i>",
                nextHtml: "<i class='fas fa-chevron-right black-text' style='font-size: xx-large;'></i>",
                responsive : [
                    {
                        breakpoint:1400,
                        settings: {
                            item:2,
                            slideMove:1,
                            slideMargin:0,
                          }
                    },
                    {
                        breakpoint:768,
                        settings: {
                            item:1,
                            slideMove:1,
                            slideMargin:6,
                          }
                    }
                ]
            });
        });
    </script>


  <footer class="page-footer text-md-left pt-4">
  
    <hr class="pb-0 mb-0">
    <div class="container-fluid">
      <div class="row   justify-content-md-center">
        <div class="col-md-3">
          <h5 class=" mb-1 footer-heading">Xanadu</h5>
          <hr width=100px class="d-inline-block mt-0 mb-1 Deep-purple accent-4">
          <p class="">Located in the heart of downtown Toronto, we've brought together exceptional minds from around the world to build quantum computers that are useful and available to people everywhere.</p>
        </div>

    <div class="col-md-2 col-4">
          <h5 class=" mb-1 footer-heading">PennyLane</h5>
          <hr width=100px class="d-inline-block mt-0 mb-1 Deep-purple accent-4">
          <ul class="list-unstyled">
            <li><a class="" href="https://pennylane.ai/">Home page</a></li>
            <li><a class="" href="https://github.com/XanaduAI/pennylane">GitHub</a></li>
            <li><a class="" href="https://pennylane.readthedocs.io/">Documentation</a></li>
            <li><a class="" href="https://discuss.pennylane.ai/">Discussion forum</a></li>
            <li><a class="" href="https://twitter.com/pennylaneai/">Twitter</a></li>
          </ul>
        </div>
		<div class="col-md-2 col-4">
          <h5 class=" mb-1 footer-heading">Strawberry Fields</h5>
          <hr width=100px class="d-inline-block mt-0 mb-1 Deep-purple accent-4">
          <ul class="list-unstyled">
            <li><a class="" href="https://strawberryfields.ai/">Interactive</a></li>
            <li><a class="" href="https://github.com/XanaduAI/strawberryfields">GitHub</a></li>
            <li><a class="" href="https://strawberryfields.readthedocs.io/">Documentation</a></li>
            <li><a class="" href="https://u.strawberryfields.ai/slack/">Slack channel</a></li>
          </ul>
        </div>


        <div class="col-md-2 col-4">
          <h5 class=" mb-1 footer-heading">About</h5>
          <hr width=100px class="d-inline-block mt-0 mb-1 Deep-purple accent-4">
          <ul class="list-unstyled">
            <li><a class="" href="https://www.xanadu.ai/">Home</a></li>
            <li><a class="" href="https://www.xanadu.ai/hardware/">Hardware</a></li>
            <li><a class="" href="https://www.xanadu.ai/software/">Software</a></li>
            <li><a class="" href="https://www.xanadu.ai/research">Research</a></li>
            <li><a class="" href="https://medium.com/XanaduAI">Blog</a></li>
            <li><a class="" href="https://www.xanadu.ai/about/">About</a></li>
          </ul>
        </div>
      </div>
    </div>
    <hr>

    <!-- <hr class="pb-0 mb-0"> -->

    <!--Social buttons-->
    <div class="social-section text-center">
        <ul class="list-unstyled list-inline mb-0">
            <li class="list-inline-item"><a class="btn-fb" href="https://www.facebook.com/Xanadu-1312050742230493/"><i class="fab fa-facebook-f"> </i></a></li>
            <li class="list-inline-item"><a class="btn-tw" href="https://twitter.com/xanaduai"><i class="fab fa-twitter"> </i></a></li>
            <li class="list-inline-item"><a class="" href="https://medium.com/xanaduai"><i class="fab fa-medium-m"> </i></a></li>
            <li class="list-inline-item"><a class="btn-li" href="https://www.linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
            <li class="list-inline-item"><a class="btn-git" href="https://github.com/XanaduAI"><i class="fab fa-github"> </i></a></li>
        </ul>
        <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">Stay updated with our newsletter</a>
    </div>
    <!--/.Social buttons-->

    <!--Copyright-->
    <div class="footer-copyright py-3 mt-0 text-center">
        <div class="container-fluid">
            © Copyright 2019 | Xanadu | All rights reserved
            <br>
             TensorFlow, the TensorFlow logo and any related marks are trademarks of Google Inc. 
        </div>
    </div>
  </footer>
  </body>
</html>